# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `packwerk` gem.
# Please instead update this file by running `bin/tapioca gem packwerk`.


# source://packwerk//lib/packwerk.rb#14
module Packwerk
  extend ::ActiveSupport::Autoload
end

# Checks the structure of the application and its packwerk configuration to make sure we can run a check and deliver
# correct results.
#
# source://packwerk//lib/packwerk/application_validator.rb#11
class Packwerk::ApplicationValidator
  include ::Packwerk::Validator
  extend ::ActiveSupport::Autoload

  # source://packwerk//lib/packwerk/application_validator.rb#25
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk//lib/packwerk/application_validator.rb#19
  sig do
    params(
      package_set: Packwerk::PackageSet,
      configuration: ::Packwerk::Configuration
    ).returns(::Packwerk::Validator::Result)
  end
  def check_all(package_set, configuration); end

  # source://packwerk//lib/packwerk/application_validator.rb#72
  sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::Validator::Result) }
  def check_application_structure(configuration); end

  # source://packwerk//lib/packwerk/application_validator.rb#87
  sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::Validator::Result) }
  def check_package_manifest_paths(configuration); end

  # source://packwerk//lib/packwerk/application_validator.rb#44
  sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::Validator::Result) }
  def check_package_manifest_syntax(configuration); end

  # source://packwerk//lib/packwerk/application_validator.rb#108
  sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::Validator::Result) }
  def check_root_package_exists(configuration); end

  # source://packwerk//lib/packwerk/application_validator.rb#37
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end

  private

  # source://packwerk//lib/packwerk/application_validator.rb#127
  sig { params(list: T.untyped).returns(T.untyped) }
  def format_yaml_strings(list); end

  # source://packwerk//lib/packwerk/application_validator.rb#132
  sig { params(configuration: ::Packwerk::Configuration, paths: T::Array[::String]).returns(T::Array[::Pathname]) }
  def relative_paths(configuration, paths); end
end

# Extracts the implicit constant reference from an active record association
#
# source://packwerk//lib/packwerk/association_inspector.rb#6
class Packwerk::AssociationInspector
  include ::Packwerk::ConstantNameInspector

  # source://packwerk//lib/packwerk/association_inspector.rb#29
  sig do
    params(
      inflector: T.class_of(ActiveSupport::Inflector),
      custom_associations: T.any(T::Array[::Symbol], T::Set[::Symbol]),
      excluded_files: T::Set[::String]
    ).void
  end
  def initialize(inflector:, custom_associations: T.unsafe(nil), excluded_files: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/association_inspector.rb#40
  sig do
    override
      .params(
        node: ::AST::Node,
        ancestors: T::Array[::AST::Node],
        relative_file: ::String
      ).returns(T.nilable(::String))
  end
  def constant_name_from_node(node, ancestors:, relative_file:); end

  private

  # source://packwerk//lib/packwerk/association_inspector.rb#65
  sig { params(node: ::AST::Node).returns(T::Boolean) }
  def association?(node); end

  # source://packwerk//lib/packwerk/association_inspector.rb#79
  sig { params(arguments: T::Array[::AST::Node]).returns(T.nilable(T.any(::String, ::Symbol))) }
  def association_name(arguments); end

  # source://packwerk//lib/packwerk/association_inspector.rb#71
  sig { params(arguments: T::Array[::AST::Node]).returns(T.nilable(::AST::Node)) }
  def custom_class_name(arguments); end

  # source://packwerk//lib/packwerk/association_inspector.rb#60
  sig { params(relative_file: ::String).returns(T::Boolean) }
  def excluded?(relative_file); end
end

# source://packwerk//lib/packwerk/association_inspector.rb#10
Packwerk::AssociationInspector::CustomAssociations = T.type_alias { T.any(T::Array[::Symbol], T::Set[::Symbol]) }

# source://packwerk//lib/packwerk/association_inspector.rb#12
Packwerk::AssociationInspector::RAILS_ASSOCIATIONS = T.let(T.unsafe(nil), Set)

# source://packwerk//lib/packwerk/cache.rb#7
class Packwerk::Cache
  # source://packwerk//lib/packwerk/cache.rb#52
  sig { params(enable_cache: T::Boolean, cache_directory: ::Pathname, config_path: T.nilable(::String)).void }
  def initialize(enable_cache:, cache_directory:, config_path:); end

  # source://packwerk//lib/packwerk/cache.rb#67
  sig { void }
  def bust_cache!; end

  # source://packwerk//lib/packwerk/cache.rb#133
  sig { params(contents: ::String, contents_key: ::Symbol).void }
  def bust_cache_if_contents_have_changed(contents, contents_key); end

  # source://packwerk//lib/packwerk/cache.rb#128
  sig { void }
  def bust_cache_if_inflections_have_changed!; end

  # source://packwerk//lib/packwerk/cache.rb#121
  sig { void }
  def bust_cache_if_packwerk_yml_has_changed!; end

  # source://packwerk//lib/packwerk/cache.rb#157
  sig { void }
  def create_cache_directory!; end

  # source://packwerk//lib/packwerk/cache.rb#109
  sig { params(file: ::String).returns(::String) }
  def digest_for_file(file); end

  # source://packwerk//lib/packwerk/cache.rb#114
  sig { params(str: ::String).returns(::String) }
  def digest_for_string(str); end

  # source://packwerk//lib/packwerk/cache.rb#77
  sig do
    params(
      file_path: ::String,
      block: T.proc.returns(T::Array[::Packwerk::UnresolvedReference])
    ).returns(T::Array[::Packwerk::UnresolvedReference])
  end
  def with_cache(file_path, &block); end
end

# source://packwerk//lib/packwerk/cache.rb#10
class Packwerk::Cache::CacheContents < ::T::Struct
  const :file_contents_digest, ::String
  const :unresolved_references, T::Array[::Packwerk::UnresolvedReference]

  # source://packwerk//lib/packwerk/cache.rb#39
  sig { returns(::String) }
  def serialize; end

  class << self
    # source://packwerk//lib/packwerk/cache.rb#20
    sig { params(serialized_cache_contents: ::String).returns(::Packwerk::Cache::CacheContents) }
    def deserialize(serialized_cache_contents); end

    # source://sorbet-runtime/0.5.11874/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk//lib/packwerk/cache.rb#44
Packwerk::Cache::CacheShape = T.type_alias { T::Hash[::String, ::Packwerk::Cache::CacheContents] }

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/checker.rb#5
module Packwerk::Checker
  abstract!

  # @abstract
  #
  # source://packwerk//lib/packwerk/checker.rb#58
  sig { abstract.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/checker.rb#61
  sig { abstract.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/checker.rb#55
  sig { abstract.params(offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(offense); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/checker.rb#52
  sig { abstract.returns(::String) }
  def violation_type; end

  class << self
    # source://packwerk//lib/packwerk/checker.rb#20
    sig { returns(T::Array[::Packwerk::Checker]) }
    def all; end

    # source://packwerk//lib/packwerk/checker.rb#26
    sig { params(violation_type: ::String).returns(::Packwerk::Checker) }
    def find(violation_type); end

    # source://packwerk//lib/packwerk/checker.rb#15
    sig { params(base: T::Class[T.anything]).void }
    def included(base); end

    private

    # source://packwerk//lib/packwerk/checker.rb#43
    sig { params(name: ::String).returns(::Packwerk::Checker) }
    def checker_by_violation_type(name); end

    # source://packwerk//lib/packwerk/checker.rb#38
    sig { returns(T::Array[T::Class[T.anything]]) }
    def checkers; end

    # source://packwerk//lib/packwerk/checker.rb#33
    sig { void }
    def load_defaults; end
  end
end

# A command-line interface to Packwerk.
#
# source://packwerk//lib/packwerk/cli.rb#6
class Packwerk::Cli
  # source://packwerk//lib/packwerk/cli.rb#19
  sig do
    params(
      configuration: T.nilable(::Packwerk::Configuration),
      out: T.any(::IO, ::StringIO),
      err_out: T.any(::IO, ::StringIO),
      environment: ::String,
      style: ::Packwerk::OutputStyle,
      offenses_formatter: T.nilable(::Packwerk::OffensesFormatter)
    ).void
  end
  def initialize(configuration: T.unsafe(nil), out: T.unsafe(nil), err_out: T.unsafe(nil), environment: T.unsafe(nil), style: T.unsafe(nil), offenses_formatter: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/cli.rb#46
  sig { params(args: T::Array[::String]).returns(T::Boolean) }
  def execute_command(args); end

  # source://packwerk//lib/packwerk/cli.rb#40
  sig { params(args: T::Array[::String]).returns(T.noreturn) }
  def run(args); end
end

# source://packwerk//lib/packwerk/commands.rb#5
module Packwerk::Commands
  extend ::ActiveSupport::Autoload

  class << self
    # source://packwerk//lib/packwerk/commands.rb#35
    sig { returns(T::Array[::Packwerk::Commands::LazyLoadedEntry]) }
    def all; end

    # source://packwerk//lib/packwerk/commands.rb#28
    sig { params(name_or_alias: ::String).returns(T.nilable(T.class_of(Packwerk::Commands::BaseCommand))) }
    def for(name_or_alias); end

    # source://packwerk//lib/packwerk/commands.rb#23
    sig { params(name: ::String, aliases: T::Array[::String]).void }
    def register(name, aliases: T.unsafe(nil)); end

    private

    # source://packwerk//lib/packwerk/commands.rb#42
    sig { returns(T::Array[::Packwerk::Commands::LazyLoadedEntry]) }
    def registry; end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/commands/base_command.rb#6
class Packwerk::Commands::BaseCommand
  abstract!

  # source://packwerk//lib/packwerk/commands/base_command.rb#36
  sig do
    params(
      args: T::Array[::String],
      configuration: ::Packwerk::Configuration,
      out: T.any(::IO, ::StringIO),
      err_out: T.any(::IO, ::StringIO),
      progress_formatter: ::Packwerk::Formatters::ProgressFormatter,
      offenses_formatter: ::Packwerk::OffensesFormatter
    ).void
  end
  def initialize(args, configuration:, out:, err_out:, progress_formatter:, offenses_formatter:); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/commands/base_command.rb#46
  sig { abstract.returns(T::Boolean) }
  def run; end

  private

  # source://packwerk//lib/packwerk/commands/base_command.rb#51
  sig { returns(T::Array[::String]) }
  def args; end

  # source://packwerk//lib/packwerk/commands/base_command.rb#54
  sig { returns(::Packwerk::Configuration) }
  def configuration; end

  # source://packwerk//lib/packwerk/commands/base_command.rb#60
  sig { returns(T.any(::IO, ::StringIO)) }
  def err_out; end

  # source://packwerk//lib/packwerk/commands/base_command.rb#66
  sig { returns(::Packwerk::OffensesFormatter) }
  def offenses_formatter; end

  # source://packwerk//lib/packwerk/commands/base_command.rb#57
  sig { returns(T.any(::IO, ::StringIO)) }
  def out; end

  # source://packwerk//lib/packwerk/commands/base_command.rb#63
  sig { returns(::Packwerk::Formatters::ProgressFormatter) }
  def progress_formatter; end

  class << self
    # source://packwerk//lib/packwerk/commands/base_command.rb#17
    sig { params(description: T.nilable(::String)).returns(::String) }
    def description(description = T.unsafe(nil)); end
  end
end

# source://packwerk//lib/packwerk/commands/check_command.rb#6
class Packwerk::Commands::CheckCommand < ::Packwerk::Commands::BaseCommand
  include ::Packwerk::Commands::UsesParseRun

  # source://packwerk//lib/packwerk/commands/check_command.rb#13
  sig { override.returns(T::Boolean) }
  def run; end

  private

  # source://packwerk//lib/packwerk/commands/check_command.rb#57
  sig { returns(::Packwerk::OffenseCollection) }
  def offense_collection; end

  # source://packwerk//lib/packwerk/commands/check_command.rb#52
  sig { returns(::Packwerk::RunContext) }
  def run_context; end
end

# source://packwerk//lib/packwerk/commands/help_command.rb#6
class Packwerk::Commands::HelpCommand < ::Packwerk::Commands::BaseCommand
  # source://packwerk//lib/packwerk/commands/help_command.rb#12
  sig { override.returns(T::Boolean) }
  def run; end

  private

  # source://packwerk//lib/packwerk/commands/help_command.rb#26
  sig { returns(::String) }
  def command_help_lines; end
end

# source://packwerk//lib/packwerk/commands/init_command.rb#6
class Packwerk::Commands::InitCommand < ::Packwerk::Commands::BaseCommand
  # source://packwerk//lib/packwerk/commands/init_command.rb#12
  sig { override.returns(T::Boolean) }
  def run; end
end

# source://packwerk//lib/packwerk/commands/lazy_loaded_entry.rb#6
class Packwerk::Commands::LazyLoadedEntry
  # source://packwerk//lib/packwerk/commands/lazy_loaded_entry.rb#13
  sig { params(name: ::String, aliases: T::Array[::String]).void }
  def initialize(name, aliases: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/commands/lazy_loaded_entry.rb#19
  sig { returns(T.class_of(Packwerk::Commands::BaseCommand)) }
  def command_class; end

  # source://packwerk//lib/packwerk/commands/lazy_loaded_entry.rb#25
  sig { returns(::String) }
  def description; end

  # source://packwerk//lib/packwerk/commands/lazy_loaded_entry.rb#30
  sig { params(name_or_alias: ::String).returns(T::Boolean) }
  def matches_command?(name_or_alias); end

  # source://packwerk//lib/packwerk/commands/lazy_loaded_entry.rb#10
  sig { returns(::String) }
  def name; end
end

# source://packwerk//lib/packwerk/commands/update_todo_command.rb#6
class Packwerk::Commands::UpdateTodoCommand < ::Packwerk::Commands::BaseCommand
  include ::Packwerk::Commands::UsesParseRun

  # source://packwerk//lib/packwerk/commands/update_todo_command.rb#13
  sig { override.returns(T::Boolean) }
  def run; end
end

# source://packwerk//lib/packwerk/commands/uses_parse_run.rb#8
module Packwerk::Commands::UsesParseRun
  requires_ancestor { Packwerk::Commands::BaseCommand }

  # source://packwerk//lib/packwerk/commands/uses_parse_run.rb#24
  sig do
    params(
      args: T::Array[::String],
      configuration: ::Packwerk::Configuration,
      out: T.any(::IO, ::StringIO),
      err_out: T.any(::IO, ::StringIO),
      progress_formatter: ::Packwerk::Formatters::ProgressFormatter,
      offenses_formatter: ::Packwerk::OffensesFormatter
    ).void
  end
  def initialize(args, configuration:, out:, err_out:, progress_formatter:, offenses_formatter:); end

  private

  # source://packwerk//lib/packwerk/commands/uses_parse_run.rb#34
  sig { returns(::Packwerk::FilesForProcessing) }
  def fetch_files_to_process; end

  # source://packwerk//lib/packwerk/commands/uses_parse_run.rb#43
  sig { returns(T.nilable(::Packwerk::OffensesFormatter)) }
  def offenses_formatter_from_options; end

  # source://packwerk//lib/packwerk/commands/uses_parse_run.rb#48
  sig { returns(::Packwerk::ParseRun) }
  def parse_run; end

  # source://packwerk//lib/packwerk/commands/uses_parse_run.rb#56
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def parsed_options; end
end

# source://packwerk//lib/packwerk/commands/validate_command.rb#6
class Packwerk::Commands::ValidateCommand < ::Packwerk::Commands::BaseCommand
  # source://packwerk//lib/packwerk/commands/validate_command.rb#12
  sig { override.returns(T::Boolean) }
  def run; end

  private

  # source://packwerk//lib/packwerk/commands/validate_command.rb#38
  sig { returns(Packwerk::PackageSet) }
  def package_set; end

  # source://packwerk//lib/packwerk/commands/validate_command.rb#33
  sig { returns(::Packwerk::ApplicationValidator) }
  def validator; end
end

# source://packwerk//lib/packwerk/commands/version_command.rb#6
class Packwerk::Commands::VersionCommand < ::Packwerk::Commands::BaseCommand
  # source://packwerk//lib/packwerk/commands/version_command.rb#12
  sig { override.returns(T::Boolean) }
  def run; end
end

# source://packwerk//lib/packwerk/configuration.rb#8
class Packwerk::Configuration
  # source://packwerk//lib/packwerk/configuration.rb#75
  sig { params(configs: T::Hash[::String, T.untyped], config_path: T.nilable(::String)).void }
  def initialize(configs = T.unsafe(nil), config_path: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/configuration.rb#58
  sig { returns(T::Array[::String]) }
  def associations_exclude; end

  # source://packwerk//lib/packwerk/configuration.rb#64
  sig { returns(::Pathname) }
  def cache_directory; end

  # source://packwerk//lib/packwerk/configuration.rb#118
  sig { returns(T::Boolean) }
  def cache_enabled?; end

  # source://packwerk//lib/packwerk/configuration.rb#61
  sig { returns(T.nilable(::String)) }
  def config_path; end

  # source://packwerk//lib/packwerk/configuration.rb#55
  sig { returns(T::Array[::Symbol]) }
  def custom_associations; end

  # source://packwerk//lib/packwerk/configuration.rb#46
  sig { returns(T::Array[::String]) }
  def exclude; end

  # source://packwerk//lib/packwerk/configuration.rb#43
  sig { returns(T::Array[::String]) }
  def include; end

  # source://packwerk//lib/packwerk/configuration.rb#100
  sig { returns(T::Hash[::String, ::Module]) }
  def load_paths; end

  # source://packwerk//lib/packwerk/configuration.rb#113
  sig { returns(::Packwerk::OffensesFormatter) }
  def offenses_formatter; end

  # source://packwerk//lib/packwerk/configuration.rb#52
  sig { returns(T.any(::String, T::Array[::String])) }
  def package_paths; end

  # source://packwerk//lib/packwerk/configuration.rb#67
  sig { params(parallel: T::Boolean).returns(T::Boolean) }
  def parallel=(parallel); end

  # source://packwerk//lib/packwerk/configuration.rb#108
  sig { returns(T::Boolean) }
  def parallel?; end

  # source://packwerk//lib/packwerk/configuration.rb#49
  sig { returns(::String) }
  def root_path; end

  class << self
    # @raise [ArgumentError]
    #
    # source://packwerk//lib/packwerk/configuration.rb#15
    sig { params(path: ::String).returns(::Packwerk::Configuration) }
    def from_path(path = T.unsafe(nil)); end

    private

    # source://packwerk//lib/packwerk/configuration.rb#30
    sig { params(path: ::String).returns(::Packwerk::Configuration) }
    def from_packwerk_config(path); end
  end
end

# source://packwerk//lib/packwerk/configuration.rb#38
Packwerk::Configuration::DEFAULT_CONFIG_PATH = T.let(T.unsafe(nil), String)

# source://packwerk//lib/packwerk/configuration.rb#40
Packwerk::Configuration::DEFAULT_EXCLUDE_GLOBS = T.let(T.unsafe(nil), Array)

# source://packwerk//lib/packwerk/configuration.rb#39
Packwerk::Configuration::DEFAULT_INCLUDE_GLOBS = T.let(T.unsafe(nil), Array)

# Extracts a constant name from an AST node of type :const
#
# source://packwerk//lib/packwerk/const_node_inspector.rb#6
class Packwerk::ConstNodeInspector
  include ::Packwerk::ConstantNameInspector

  # source://packwerk//lib/packwerk/const_node_inspector.rb#15
  sig do
    override
      .params(
        node: ::AST::Node,
        ancestors: T::Array[::AST::Node],
        relative_file: ::String
      ).returns(T.nilable(::String))
  end
  def constant_name_from_node(node, ancestors:, relative_file:); end

  private

  # source://packwerk//lib/packwerk/const_node_inspector.rb#43
  sig { params(node: ::AST::Node, parent: ::AST::Node).returns(T.nilable(T::Boolean)) }
  def constant_in_module_or_class_definition?(node, parent:); end

  # source://packwerk//lib/packwerk/const_node_inspector.rb#49
  sig { params(ancestors: T::Array[::AST::Node]).returns(::String) }
  def fully_qualify_constant(ancestors); end

  # source://packwerk//lib/packwerk/const_node_inspector.rb#38
  sig { params(parent: T.nilable(::AST::Node)).returns(T::Boolean) }
  def root_constant?(parent); end
end

# source://packwerk//lib/packwerk/constant_context.rb#7
class Packwerk::ConstantContext < ::Struct
  # Returns the value of attribute location
  #
  # @return [Object] the current value of location
  def location; end

  # Sets the attribute location
  #
  # @param value [Object] the value to set the attribute location to.
  # @return [Object] the newly set value
  def location=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute package
  #
  # @return [Object] the current value of package
  def package; end

  # Sets the attribute package
  #
  # @param value [Object] the value to set the attribute package to.
  # @return [Object] the newly set value
  def package=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Get information about unresolved constants without loading the application code.
# Information gathered: Fully qualified name, path to file containing the definition, package,
# and visibility (public/private to the package).
#
# The implementation makes a few assumptions about the code base:
# - `Something::SomeOtherThing` is defined in a path of either `something/some_other_thing.rb` or `something.rb`,
#   relative to the load path. Rails' `zeitwerk` autoloader makes the same assumption.
# - It is OK to not always infer the exact file defining the constant. For example, when a constant is inherited, we
#   have no way of inferring the file it is defined in. You could argue though that inheritance means that another
#   constant with the same name exists in the inheriting class, and this view is sufficient for all our use cases.
#
# source://packwerk//lib/packwerk/constant_discovery.rb#17
class Packwerk::ConstantDiscovery
  # source://packwerk//lib/packwerk/constant_discovery.rb#25
  sig { params(constant_resolver: ::ConstantResolver, packages: Packwerk::PackageSet).void }
  def initialize(constant_resolver:, packages:); end

  # Analyze a constant via its name.
  # If the constant is unresolved, we need the current namespace path to correctly infer its full name
  #
  # source://packwerk//lib/packwerk/constant_discovery.rb#58
  sig do
    params(
      const_name: ::String,
      current_namespace_path: T.nilable(T::Array[::String])
    ).returns(T.nilable(::Packwerk::ConstantContext))
  end
  def context_for(const_name, current_namespace_path: T.unsafe(nil)); end

  # Get the package that owns a given file path.
  #
  # source://packwerk//lib/packwerk/constant_discovery.rb#41
  sig { params(path: ::String).returns(::Packwerk::Package) }
  def package_from_path(path); end
end

# An interface describing an object that can extract a constant name from an AST node.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/constant_name_inspector.rb#8
module Packwerk::ConstantNameInspector
  interface!

  # @abstract
  #
  # source://packwerk//lib/packwerk/constant_name_inspector.rb#19
  sig do
    abstract
      .params(
        node: ::AST::Node,
        ancestors: T::Array[::AST::Node],
        relative_file: ::String
      ).returns(T.nilable(::String))
  end
  def constant_name_from_node(node, ancestors:, relative_file:); end
end

# source://packwerk//lib/packwerk/cache.rb#162
class Packwerk::Debug
  class << self
    # source://packwerk//lib/packwerk/cache.rb#167
    sig { params(out: ::String).void }
    def out(out); end
  end
end

# This class handles loading extensions to packwerk using the `require` directive
# in the `packwerk.yml` configuration.
#
# source://packwerk//lib/packwerk/extension_loader.rb#7
module Packwerk::ExtensionLoader
  class << self
    # source://packwerk//lib/packwerk/extension_loader.rb#11
    sig { params(require_directive: ::String, config_dir_path: ::String).void }
    def load(require_directive, config_dir_path); end
  end
end

# source://packwerk//lib/packwerk/file_processor.rb#7
class Packwerk::FileProcessor
  # source://packwerk//lib/packwerk/file_processor.rb#26
  sig do
    params(
      node_processor_factory: ::Packwerk::NodeProcessorFactory,
      cache: ::Packwerk::Cache,
      parser_factory: T.nilable(::Packwerk::Parsers::Factory)
    ).void
  end
  def initialize(node_processor_factory:, cache:, parser_factory: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/file_processor.rb#40
  sig { params(relative_file: ::String).returns(::Packwerk::FileProcessor::ProcessedFile) }
  def call(relative_file); end

  private

  # source://packwerk//lib/packwerk/file_processor.rb#85
  sig { params(relative_file: ::String, parser: ::Packwerk::Parsers::ParserInterface).returns(T.untyped) }
  def parse_into_ast(relative_file, parser); end

  # source://packwerk//lib/packwerk/file_processor.rb#92
  sig { params(file_path: ::String).returns(T.nilable(::Packwerk::Parsers::ParserInterface)) }
  def parser_for(file_path); end

  # source://packwerk//lib/packwerk/file_processor.rb#74
  sig { params(node: ::Parser::AST::Node, relative_file: ::String).returns(T::Array[::Packwerk::UnresolvedReference]) }
  def references_from_ast(node, relative_file); end
end

# source://packwerk//lib/packwerk/file_processor.rb#32
class Packwerk::FileProcessor::ProcessedFile < ::T::Struct
  const :unresolved_references, T::Array[::Packwerk::UnresolvedReference], default: T.unsafe(nil)
  const :offenses, T::Array[::Packwerk::Offense], default: T.unsafe(nil)

  class << self
    # source://sorbet-runtime/0.5.11874/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk//lib/packwerk/file_processor.rb#10
class Packwerk::FileProcessor::UnknownFileTypeResult < ::Packwerk::Offense
  # source://packwerk//lib/packwerk/file_processor.rb#14
  sig { params(file: ::String).void }
  def initialize(file:); end
end

# source://packwerk//lib/packwerk/files_for_processing.rb#5
class Packwerk::FilesForProcessing
  # source://packwerk//lib/packwerk/files_for_processing.rb#32
  sig do
    params(
      relative_file_paths: T::Array[::String],
      configuration: ::Packwerk::Configuration,
      ignore_nested_packages: T::Boolean
    ).void
  end
  def initialize(relative_file_paths, configuration, ignore_nested_packages); end

  # source://packwerk//lib/packwerk/files_for_processing.rb#41
  sig { returns(T::Set[::String]) }
  def files; end

  # source://packwerk//lib/packwerk/files_for_processing.rb#46
  sig { returns(T::Boolean) }
  def files_specified?; end

  private

  # source://packwerk//lib/packwerk/files_for_processing.rb#105
  sig { returns(T::Set[::String]) }
  def configured_excluded_files; end

  # source://packwerk//lib/packwerk/files_for_processing.rb#100
  sig { returns(T::Set[::String]) }
  def configured_included_files; end

  # source://packwerk//lib/packwerk/files_for_processing.rb#53
  sig { returns(T::Set[::String]) }
  def files_for_processing; end

  # source://packwerk//lib/packwerk/files_for_processing.rb#110
  sig { params(relative_globs: T::Array[::String]).returns(T::Set[::String]) }
  def relative_files_for_globs(relative_globs); end

  # source://packwerk//lib/packwerk/files_for_processing.rb#64
  sig { returns(T::Set[::String]) }
  def specified_files; end

  # source://packwerk//lib/packwerk/files_for_processing.rb#77
  sig { params(relative_file_path: ::String).returns(T::Set[::String]) }
  def specified_included_files(relative_file_path); end

  class << self
    # source://packwerk//lib/packwerk/files_for_processing.rb#20
    sig do
      params(
        relative_file_paths: T::Array[::String],
        configuration: ::Packwerk::Configuration,
        ignore_nested_packages: T::Boolean
      ).returns(::Packwerk::FilesForProcessing)
    end
    def fetch(relative_file_paths:, configuration:, ignore_nested_packages: T.unsafe(nil)); end
  end
end

# source://packwerk//lib/packwerk/files_for_processing.rb#8
Packwerk::FilesForProcessing::RelativeFileSet = T.type_alias { T::Set[::String] }

# source://packwerk//lib/packwerk.rb#44
module Packwerk::Formatters
  extend ::ActiveSupport::Autoload
end

# source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#6
class Packwerk::Formatters::DefaultOffensesFormatter
  include ::Packwerk::OffensesFormatter

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#33
  sig { override.returns(::String) }
  def identifier; end

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#14
  sig { override.params(offenses: T::Array[T.nilable(::Packwerk::Offense)]).returns(::String) }
  def show_offenses(offenses); end

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#24
  sig do
    override
      .params(
        offense_collection: ::Packwerk::OffenseCollection,
        file_set: T::Set[::String]
      ).returns(::String)
  end
  def show_stale_violations(offense_collection, file_set); end

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#38
  sig { override.params(strict_mode_violations: T::Array[::Packwerk::ReferenceOffense]).returns(::String) }
  def show_strict_mode_violations(strict_mode_violations); end

  private

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#54
  sig { params(offense: ::Packwerk::ReferenceOffense).returns(::String) }
  def format_strict_mode_violation(offense); end

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#63
  sig { params(offenses: T::Array[T.nilable(::Packwerk::Offense)]).returns(::String) }
  def offenses_list(offenses); end

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#71
  sig { params(offenses: T::Array[T.nilable(::Packwerk::Offense)]).returns(::String) }
  def offenses_summary(offenses); end

  # source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#49
  sig { returns(::Packwerk::OutputStyle) }
  def style; end
end

# source://packwerk//lib/packwerk/formatters/default_offenses_formatter.rb#9
Packwerk::Formatters::DefaultOffensesFormatter::IDENTIFIER = T.let(T.unsafe(nil), String)

# source://packwerk//lib/packwerk/formatters/progress_formatter.rb#8
class Packwerk::Formatters::ProgressFormatter
  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#12
  sig { params(out: T.any(::IO, ::StringIO), style: ::Packwerk::OutputStyle).void }
  def initialize(out, style: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#34
  sig { params(failed: T::Boolean).void }
  def increment_progress(failed = T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#53
  sig { void }
  def interrupted; end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#48
  sig { void }
  def mark_as_failed; end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#43
  sig { void }
  def mark_as_inspected; end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#26
  sig { params(target_files: T::Set[::String], block: T.proc.void).void }
  def started_inspection(target_files, &block); end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#18
  sig { params(block: T.proc.void).void }
  def started_validation(&block); end

  private

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#62
  sig { params(execution_time: ::Float).void }
  def finished(execution_time); end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#74
  sig { params(target_files: T::Set[::String]).void }
  def start_inspection(target_files); end

  # source://packwerk//lib/packwerk/formatters/progress_formatter.rb#69
  sig { void }
  def start_validation; end
end

# source://packwerk//lib/packwerk.rb#79
module Packwerk::Generators
  extend ::ActiveSupport::Autoload
end

# source://packwerk//lib/packwerk/generators/configuration_file.rb#8
class Packwerk::Generators::ConfigurationFile
  # source://packwerk//lib/packwerk/generators/configuration_file.rb#23
  sig { params(root: ::String, out: T.any(::IO, ::StringIO)).void }
  def initialize(root:, out: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/generators/configuration_file.rb#29
  sig { returns(T::Boolean) }
  def generate; end

  private

  # source://packwerk//lib/packwerk/generators/configuration_file.rb#47
  sig { returns(::String) }
  def render; end

  # source://packwerk//lib/packwerk/generators/configuration_file.rb#52
  sig { returns(::String) }
  def template; end

  class << self
    # source://packwerk//lib/packwerk/generators/configuration_file.rb#17
    sig { params(root: ::String, out: T.any(::IO, ::StringIO)).returns(T::Boolean) }
    def generate(root:, out:); end
  end
end

# source://packwerk//lib/packwerk/generators/configuration_file.rb#11
Packwerk::Generators::ConfigurationFile::CONFIGURATION_TEMPLATE_FILE_PATH = T.let(T.unsafe(nil), String)

# source://packwerk//lib/packwerk/generators/root_package.rb#6
class Packwerk::Generators::RootPackage
  # source://packwerk//lib/packwerk/generators/root_package.rb#19
  sig { params(root: ::String, out: T.any(::IO, ::StringIO)).void }
  def initialize(root:, out: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/generators/root_package.rb#25
  sig { returns(T::Boolean) }
  def generate; end

  class << self
    # source://packwerk//lib/packwerk/generators/root_package.rb#13
    sig { params(root: ::String, out: T.any(::IO, ::StringIO)).returns(T::Boolean) }
    def generate(root:, out:); end
  end
end

# A general implementation of a graph data structure with the ability to check for - and list - cycles.
#
# source://packwerk//lib/packwerk/graph.rb#6
class Packwerk::Graph
  # source://packwerk//lib/packwerk/graph.rb#14
  sig { params(edges: T::Array[T::Array[T.nilable(T.any(::Integer, ::String))]]).void }
  def initialize(edges); end

  # @return [Boolean]
  #
  # source://packwerk//lib/packwerk/graph.rb#24
  def acyclic?; end

  # source://packwerk//lib/packwerk/graph.rb#20
  def cycles; end

  private

  # source://packwerk//lib/packwerk/graph.rb#74
  def add_cycle(cycle); end

  # source://packwerk//lib/packwerk/graph.rb#67
  def neighbours(node); end

  # source://packwerk//lib/packwerk/graph.rb#30
  def nodes; end

  # source://packwerk//lib/packwerk/graph.rb#34
  def process; end

  # source://packwerk//lib/packwerk/graph.rb#42
  def visit(node, visited_nodes: T.unsafe(nil), path: T.unsafe(nil)); end
end

# source://packwerk//lib/packwerk/node.rb#5
module Packwerk::Node; end

# source://packwerk//lib/packwerk/node.rb#6
class Packwerk::Node::Location < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Convenience methods for working with Parser::AST::Node nodes.
#
# source://packwerk//lib/packwerk/node_helpers.rb#9
module Packwerk::NodeHelpers
  class << self
    # source://packwerk//lib/packwerk/node_helpers.rb#122
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def class?(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#16
    sig { params(class_or_module_node: ::AST::Node).returns(::String) }
    def class_or_module_name(class_or_module_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#112
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def constant?(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#117
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def constant_assignment?(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#31
    sig { params(constant_node: ::AST::Node).returns(::String) }
    def constant_name(constant_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#68
    sig do
      params(
        node: ::AST::Node,
        block: T.nilable(T.proc.params(arg0: ::Parser::AST::Node).void)
      ).returns(T::Enumerable[::AST::Node])
    end
    def each_child(node, &block); end

    # source://packwerk//lib/packwerk/node_helpers.rb#79
    sig { params(starting_node: ::AST::Node, ancestors: T::Array[::AST::Node]).returns(T::Array[::String]) }
    def enclosing_namespace_path(starting_node, ancestors:); end

    # source://packwerk//lib/packwerk/node_helpers.rb#132
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def hash?(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#92
    sig { params(string_or_symbol_node: ::AST::Node).returns(T.any(::String, ::Symbol)) }
    def literal_value(string_or_symbol_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#106
    sig { params(node: ::Parser::AST::Node).returns(::Packwerk::Node::Location) }
    def location(node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#147
    sig { params(method_call_node: ::AST::Node).returns(T::Array[::AST::Node]) }
    def method_arguments(method_call_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#127
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def method_call?(node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#156
    sig { params(method_call_node: ::AST::Node).returns(::Symbol) }
    def method_name(method_call_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#165
    sig { params(node: ::AST::Node).returns(T.nilable(::String)) }
    def module_name_from_definition(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#190
    sig { params(node: ::AST::Node).returns(T.nilable(::Packwerk::Node::Location)) }
    def name_location(node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#200
    sig { params(class_node: ::AST::Node).returns(T.nilable(::AST::Node)) }
    def parent_class(class_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#209
    sig { params(ancestors: T::Array[::AST::Node]).returns(::String) }
    def parent_module_name(ancestors:); end

    # source://packwerk//lib/packwerk/node_helpers.rb#137
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def string?(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#142
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def symbol?(node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#221
    sig { params(hash_node: ::AST::Node, key: ::Symbol).returns(T.untyped) }
    def value_from_hash(hash_node, key); end

    private

    # source://packwerk//lib/packwerk/node_helpers.rb#303
    sig { params(node: T.nilable(::AST::Node)).returns(T::Boolean) }
    def dynamic_class_creation?(node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#254
    sig { params(hash_pair_node: ::AST::Node).returns(T.untyped) }
    def hash_pair_key(hash_pair_node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#265
    sig { params(hash_pair_node: ::AST::Node).returns(T.untyped) }
    def hash_pair_value(hash_pair_node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#276
    sig { params(hash_node: ::AST::Node).returns(T::Array[::AST::Node]) }
    def hash_pairs(hash_node); end

    # @raise [TypeError]
    #
    # source://packwerk//lib/packwerk/node_helpers.rb#285
    sig { params(block_node: ::AST::Node).returns(::AST::Node) }
    def method_call_node(block_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#294
    sig { params(node: ::AST::Node).returns(T::Boolean) }
    def module_creation?(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#310
    sig { params(node: ::AST::Node).returns(T.nilable(::String)) }
    def name_from_block_definition(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#318
    sig { params(node: ::AST::Node).returns(T.nilable(::String)) }
    def name_part_from_definition(node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#328
    sig { params(method_call_or_block_node: ::AST::Node).returns(T.nilable(::AST::Node)) }
    def receiver(method_call_or_block_node); end

    # source://packwerk//lib/packwerk/node_helpers.rb#249
    sig { params(node: ::AST::Node).returns(::Symbol) }
    def type_of(node); end
  end
end

# source://packwerk//lib/packwerk/node_helpers.rb#10
class Packwerk::NodeHelpers::TypeError < ::ArgumentError; end

# Processes a single node in an abstract syntax tree (AST) using the provided checkers.
#
# source://packwerk//lib/packwerk/node_processor.rb#6
class Packwerk::NodeProcessor
  # source://packwerk//lib/packwerk/node_processor.rb#15
  sig { params(reference_extractor: ::Packwerk::ReferenceExtractor, relative_file: ::String).void }
  def initialize(reference_extractor:, relative_file:); end

  # source://packwerk//lib/packwerk/node_processor.rb#26
  sig do
    params(
      node: ::Parser::AST::Node,
      ancestors: T::Array[::Parser::AST::Node]
    ).returns(T.nilable(::Packwerk::UnresolvedReference))
  end
  def call(node, ancestors); end
end

# source://packwerk//lib/packwerk/node_processor_factory.rb#5
class Packwerk::NodeProcessorFactory < ::T::Struct
  const :root_path, ::String
  const :context_provider, ::Packwerk::ConstantDiscovery
  const :constant_name_inspectors, T::Array[::Packwerk::ConstantNameInspector]

  # source://packwerk//lib/packwerk/node_processor_factory.rb#13
  sig { params(relative_file: ::String, node: ::AST::Node).returns(::Packwerk::NodeProcessor) }
  def for(relative_file:, node:); end

  private

  # source://packwerk//lib/packwerk/node_processor_factory.rb#23
  sig { params(node: ::AST::Node).returns(::Packwerk::ReferenceExtractor) }
  def reference_extractor(node:); end

  class << self
    # source://sorbet-runtime/0.5.11874/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Visits all nodes of an AST, processing them using a given node processor.
#
# source://packwerk//lib/packwerk/node_visitor.rb#6
class Packwerk::NodeVisitor
  # source://packwerk//lib/packwerk/node_visitor.rb#10
  sig { params(node_processor: ::Packwerk::NodeProcessor).void }
  def initialize(node_processor:); end

  # source://packwerk//lib/packwerk/node_visitor.rb#21
  sig do
    params(
      node: ::Parser::AST::Node,
      ancestors: T::Array[::Parser::AST::Node],
      result: T::Array[::Packwerk::UnresolvedReference]
    ).void
  end
  def visit(node, ancestors:, result:); end
end

# source://packwerk//lib/packwerk/offense.rb#7
class Packwerk::Offense
  # source://packwerk//lib/packwerk/offense.rb#24
  sig { params(file: ::String, message: ::String, location: T.nilable(::Packwerk::Node::Location)).void }
  def initialize(file:, message:, location: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/offense.rb#15
  sig { returns(::String) }
  def file; end

  # source://packwerk//lib/packwerk/offense.rb#12
  sig { returns(T.nilable(::Packwerk::Node::Location)) }
  def location; end

  # source://packwerk//lib/packwerk/offense.rb#18
  sig { returns(::String) }
  def message; end

  # source://packwerk//lib/packwerk/offense.rb#31
  sig { params(style: ::Packwerk::OutputStyle).returns(::String) }
  def to_s(style = T.unsafe(nil)); end
end

# source://packwerk//lib/packwerk/offense_collection.rb#7
class Packwerk::OffenseCollection
  # source://packwerk//lib/packwerk/offense_collection.rb#17
  sig { params(root_path: ::String, package_todos: T::Hash[::Packwerk::Package, ::Packwerk::PackageTodo]).void }
  def initialize(root_path, package_todos = T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/offense_collection.rb#52
  sig { params(offense: ::Packwerk::Offense).void }
  def add_offense(offense); end

  # source://packwerk//lib/packwerk/offense_collection.rb#45
  sig { params(offenses: T::Array[::Packwerk::Offense]).void }
  def add_offenses(offenses); end

  # source://packwerk//lib/packwerk/offense_collection.rb#29
  sig { returns(T::Array[::Packwerk::Offense]) }
  def errors; end

  # source://packwerk//lib/packwerk/offense_collection.rb#38
  sig { params(offense: ::Packwerk::Offense).returns(T::Boolean) }
  def listed?(offense); end

  # source://packwerk//lib/packwerk/offense_collection.rb#26
  sig { returns(T::Array[::Packwerk::ReferenceOffense]) }
  def new_violations; end

  # source://packwerk//lib/packwerk/offense_collection.rb#84
  sig { returns(T::Array[::Packwerk::Offense]) }
  def outstanding_offenses; end

  # source://packwerk//lib/packwerk/offense_collection.rb#78
  sig { params(package_set: Packwerk::PackageSet).void }
  def persist_package_todo_files(package_set); end

  # source://packwerk//lib/packwerk/offense_collection.rb#71
  sig { params(for_files: T::Set[::String]).returns(T::Boolean) }
  def stale_violations?(for_files); end

  # source://packwerk//lib/packwerk/offense_collection.rb#32
  sig { returns(T::Array[::Packwerk::ReferenceOffense]) }
  def strict_mode_violations; end

  # source://packwerk//lib/packwerk/offense_collection.rb#89
  sig { returns(T::Array[::Packwerk::ReferenceOffense]) }
  def unlisted_strict_mode_violations; end

  private

  # source://packwerk//lib/packwerk/offense_collection.rb#102
  sig { params(offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def add_to_package_todo(offense); end

  # source://packwerk//lib/packwerk/offense_collection.rb#96
  sig { params(offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def already_listed?(offense); end

  # source://packwerk//lib/packwerk/offense_collection.rb#114
  sig { params(package_set: Packwerk::PackageSet).void }
  def cleanup_extra_package_todo_files(package_set); end

  # source://packwerk//lib/packwerk/offense_collection.rb#126
  sig { void }
  def dump_package_todo_files; end

  # source://packwerk//lib/packwerk/offense_collection.rb#139
  sig { params(package: ::Packwerk::Package).returns(::String) }
  def package_todo_file_for(package); end

  # source://packwerk//lib/packwerk/offense_collection.rb#131
  sig { params(package: ::Packwerk::Package).returns(::Packwerk::PackageTodo) }
  def package_todo_for(package); end

  # source://packwerk//lib/packwerk/offense_collection.rb#108
  sig { params(offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(offense); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/offenses_formatter.rb#5
module Packwerk::OffensesFormatter
  abstract!

  # @abstract
  #
  # source://packwerk//lib/packwerk/offenses_formatter.rb#78
  sig { abstract.returns(::String) }
  def identifier; end

  # @abstract
  #
  # source://packwerk//lib/packwerk/offenses_formatter.rb#70
  sig { abstract.params(offenses: T::Array[T.nilable(::Packwerk::Offense)]).returns(::String) }
  def show_offenses(offenses); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/offenses_formatter.rb#74
  sig do
    abstract
      .params(
        offense_collection: ::Packwerk::OffenseCollection,
        for_files: T::Set[::String]
      ).returns(::String)
  end
  def show_stale_violations(offense_collection, for_files); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/offenses_formatter.rb#82
  sig { abstract.params(strict_mode_violations: T::Array[::Packwerk::ReferenceOffense]).returns(::String) }
  def show_strict_mode_violations(strict_mode_violations); end

  class << self
    # source://packwerk//lib/packwerk/offenses_formatter.rb#29
    sig { returns(T::Array[::Packwerk::OffensesFormatter]) }
    def all; end

    # source://packwerk//lib/packwerk/offenses_formatter.rb#35
    sig { params(identifier: ::String).returns(::Packwerk::OffensesFormatter) }
    def find(identifier); end

    # source://packwerk//lib/packwerk/offenses_formatter.rb#24
    sig { params(base: T::Class[T.anything]).void }
    def included(base); end

    private

    # source://packwerk//lib/packwerk/offenses_formatter.rb#52
    sig { params(name: ::String).returns(::Packwerk::OffensesFormatter) }
    def formatter_by_identifier(name); end

    # source://packwerk//lib/packwerk/offenses_formatter.rb#42
    sig { void }
    def load_defaults; end

    # source://packwerk//lib/packwerk/offenses_formatter.rb#47
    sig { returns(T::Array[T::Class[T.anything]]) }
    def offenses_formatters; end
  end
end

# source://packwerk//lib/packwerk/offenses_formatter.rb#11
class Packwerk::OffensesFormatter::DuplicateFormatterError < ::StandardError
  # source://packwerk//lib/packwerk/offenses_formatter.rb#15
  sig { params(identifier: ::String).void }
  def initialize(identifier); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/output_style.rb#5
module Packwerk::OutputStyle
  interface!

  # @abstract
  #
  # source://packwerk//lib/packwerk/output_style.rb#18
  sig { abstract.returns(::String) }
  def error; end

  # @abstract
  #
  # source://packwerk//lib/packwerk/output_style.rb#15
  sig { abstract.returns(::String) }
  def filename; end

  # @abstract
  #
  # source://packwerk//lib/packwerk/output_style.rb#12
  sig { abstract.returns(::String) }
  def reset; end
end

# source://packwerk//lib/packwerk.rb#37
module Packwerk::OutputStyles
  extend ::ActiveSupport::Autoload
end

# See https://en.wikipedia.org/wiki/ANSI_escape_code#3/4_bit for ANSI escape colour codes
#
# source://packwerk//lib/packwerk/output_styles/coloured.rb#7
class Packwerk::OutputStyles::Coloured
  include ::Packwerk::OutputStyle

  # source://packwerk//lib/packwerk/output_styles/coloured.rb#23
  sig { override.returns(::String) }
  def error; end

  # source://packwerk//lib/packwerk/output_styles/coloured.rb#17
  sig { override.returns(::String) }
  def filename; end

  # source://packwerk//lib/packwerk/output_styles/coloured.rb#12
  sig { override.returns(::String) }
  def reset; end
end

# source://packwerk//lib/packwerk/output_styles/plain.rb#6
class Packwerk::OutputStyles::Plain
  include ::Packwerk::OutputStyle

  # source://packwerk//lib/packwerk/output_styles/plain.rb#21
  sig { override.returns(::String) }
  def error; end

  # source://packwerk//lib/packwerk/output_styles/plain.rb#16
  sig { override.returns(::String) }
  def filename; end

  # source://packwerk//lib/packwerk/output_styles/plain.rb#11
  sig { override.returns(::String) }
  def reset; end
end

# The basic unit of modularity for packwerk; a folder that has been declared to define a package.
# The package contains all constants defined in files in this folder and all subfolders that are not packages
# themselves.
#
# source://packwerk//lib/packwerk/package.rb#8
class Packwerk::Package
  include ::Comparable

  # source://packwerk//lib/packwerk/package.rb#24
  sig { params(name: ::String, config: T.nilable(T::Hash[::String, T.untyped])).void }
  def initialize(name:, config: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/package.rb#49
  sig { params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://packwerk//lib/packwerk/package.rb#21
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def config; end

  # source://packwerk//lib/packwerk/package.rb#18
  sig { returns(T::Array[::String]) }
  def dependencies; end

  # source://packwerk//lib/packwerk/package.rb#37
  sig { params(package: ::Packwerk::Package).returns(T::Boolean) }
  def dependency?(package); end

  # source://packwerk//lib/packwerk/package.rb#32
  sig { returns(T::Boolean) }
  def enforce_dependencies?; end

  # source://packwerk//lib/packwerk/package.rb#56
  sig { params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://packwerk//lib/packwerk/package.rb#61
  sig { returns(::Integer) }
  def hash; end

  # source://packwerk//lib/packwerk/package.rb#15
  sig { returns(::String) }
  def name; end

  # source://packwerk//lib/packwerk/package.rb#42
  sig { params(path: ::String).returns(T::Boolean) }
  def package_path?(path); end

  # source://packwerk//lib/packwerk/package.rb#71
  sig { returns(T::Boolean) }
  def root?; end

  # source://packwerk//lib/packwerk/package.rb#66
  sig { returns(::String) }
  def to_s; end
end

# source://packwerk//lib/packwerk/package.rb#12
Packwerk::Package::ROOT_PACKAGE_NAME = T.let(T.unsafe(nil), String)

# A set of {Packwerk::Package}s as well as methods to parse packages from the filesystem.
#
# source://packwerk//lib/packwerk/package_set.rb#11
class Packwerk::PackageSet
  extend T::Generic
  include ::Enumerable

  Elem = type_member { { fixed: Packwerk::Package } }

  # source://packwerk//lib/packwerk/package_set.rb#79
  sig { params(packages: T::Array[::Packwerk::Package]).void }
  def initialize(packages); end

  # source://packwerk//lib/packwerk/package_set.rb#88
  sig { override.params(blk: T.proc.params(arg0: ::Packwerk::Package).returns(T.untyped)).returns(T.untyped) }
  def each(&blk); end

  # source://packwerk//lib/packwerk/package_set.rb#93
  sig { params(name: ::String).returns(T.nilable(::Packwerk::Package)) }
  def fetch(name); end

  # source://packwerk//lib/packwerk/package_set.rb#98
  sig { params(file_path: T.any(::Pathname, ::String)).returns(::Packwerk::Package) }
  def package_from_path(file_path); end

  # source://packwerk//lib/packwerk/package_set.rb#76
  sig { returns(T::Hash[::String, ::Packwerk::Package]) }
  def packages; end

  class << self
    # source://packwerk//lib/packwerk/package_set.rb#24
    sig do
      params(
        root_path: ::String,
        package_pathspec: T.nilable(T.any(::String, T::Array[::String]))
      ).returns(Packwerk::PackageSet)
    end
    def load_all_from(root_path, package_pathspec: T.unsafe(nil)); end

    # source://packwerk//lib/packwerk/package_set.rb#44
    sig do
      params(
        root_path: ::String,
        package_pathspec: T.any(::String, T::Array[::String]),
        exclude_pathspec: T.nilable(T.any(::String, T::Array[::String]))
      ).returns(T::Array[::Pathname])
    end
    def package_paths(root_path, package_pathspec, exclude_pathspec = T.unsafe(nil)); end

    private

    # source://packwerk//lib/packwerk/package_set.rb#61
    sig { params(packages: T::Array[::Packwerk::Package]).void }
    def create_root_package_if_none_in(packages); end

    # source://packwerk//lib/packwerk/package_set.rb#68
    sig { params(globs: T::Array[::String], path: ::Pathname).returns(T::Boolean) }
    def exclude_path?(globs, path); end
  end
end

# source://packwerk//lib/packwerk/package_set.rb#18
Packwerk::PackageSet::PACKAGE_CONFIG_FILENAME = T.let(T.unsafe(nil), String)

# source://packwerk//lib/packwerk/package_todo.rb#7
class Packwerk::PackageTodo
  # source://packwerk//lib/packwerk/package_todo.rb#19
  sig { params(package: ::Packwerk::Package, path: ::String).void }
  def initialize(package, path); end

  # source://packwerk//lib/packwerk/package_todo.rb#43
  sig { params(reference: ::Packwerk::Reference, violation_type: ::String).returns(T::Boolean) }
  def add_entries(reference, violation_type); end

  # source://packwerk//lib/packwerk/package_todo.rb#97
  sig { void }
  def delete_if_exists; end

  # source://packwerk//lib/packwerk/package_todo.rb#75
  sig { void }
  def dump; end

  # source://packwerk//lib/packwerk/package_todo.rb#30
  sig { params(reference: ::Packwerk::Reference, violation_type: ::String).returns(T::Boolean) }
  def listed?(reference, violation_type:); end

  # source://packwerk//lib/packwerk/package_todo.rb#58
  sig { params(for_files: T::Set[::String]).returns(T::Boolean) }
  def stale_violations?(for_files); end

  private

  # source://packwerk//lib/packwerk/package_todo.rb#107
  sig { params(package: ::String).returns(T::Array[::String]) }
  def deleted_files_for(package); end

  # source://packwerk//lib/packwerk/package_todo.rb#168
  sig { params(path: ::String).returns(T::Hash[::String, T::Hash[::String, T::Hash[::String, T::Array[::String]]]]) }
  def load_yaml_file(path); end

  # source://packwerk//lib/packwerk/package_todo.rb#104
  sig { returns(T::Hash[::String, T::Hash[::String, T::Hash[::String, T::Array[::String]]]]) }
  def new_entries; end

  # source://packwerk//lib/packwerk/package_todo.rb#163
  sig { returns(T::Hash[::String, T::Hash[::String, T::Hash[::String, T::Array[::String]]]]) }
  def old_entries; end

  # source://packwerk//lib/packwerk/package_todo.rb#133
  sig do
    params(
      package_violations: T::Hash[::String, T::Hash[::String, T::Array[::String]]],
      files: T::Set[::String]
    ).returns(T::Hash[::String, T::Hash[::String, T::Array[::String]]])
  end
  def package_violations_for(package_violations, files:); end

  # source://packwerk//lib/packwerk/package_todo.rb#150
  sig { returns(T::Hash[::String, T::Hash[::String, T::Hash[::String, T::Array[::String]]]]) }
  def prepare_entries_for_dump; end

  # source://packwerk//lib/packwerk/package_todo.rb#114
  sig do
    params(
      package: ::String,
      violations: T::Hash[::String, T::Hash[::String, T::Array[::String]]]
    ).returns(T::Boolean)
  end
  def stale_violation_for_package?(package, violations:); end
end

# source://packwerk//lib/packwerk/package_todo.rb#11
Packwerk::PackageTodo::ConstantName = T.type_alias { ::String }

# source://packwerk//lib/packwerk/package_todo.rb#14
Packwerk::PackageTodo::Entries = T.type_alias { T::Hash[::String, T::Hash[::String, T::Hash[::String, T::Array[::String]]]] }

# source://packwerk//lib/packwerk/package_todo.rb#13
Packwerk::PackageTodo::Entry = T.type_alias { T::Hash[::String, T::Hash[::String, T::Array[::String]]] }

# source://packwerk//lib/packwerk/package_todo.rb#12
Packwerk::PackageTodo::FilePath = T.type_alias { ::String }

# source://packwerk//lib/packwerk/package_todo.rb#10
Packwerk::PackageTodo::PackageName = T.type_alias { ::String }

# source://packwerk//lib/packwerk/parse_run.rb#7
class Packwerk::ParseRun
  # source://packwerk//lib/packwerk/parse_run.rb#20
  sig { params(relative_file_set: T::Set[::String], parallel: T::Boolean).void }
  def initialize(relative_file_set:, parallel:); end

  # source://packwerk//lib/packwerk/parse_run.rb#34
  sig do
    params(
      run_context: ::Packwerk::RunContext,
      on_interrupt: T.nilable(T.proc.void),
      block: T.nilable(T.proc.params(offenses: T::Array[::Packwerk::Offense]).void)
    ).returns(T::Array[::Packwerk::Offense])
  end
  def find_offenses(run_context, on_interrupt: T.unsafe(nil), &block); end

  private

  # source://packwerk//lib/packwerk/parse_run.rb#54
  sig do
    params(
      run_context: ::Packwerk::RunContext,
      block: T.nilable(T.proc.params(offenses: T::Array[::Packwerk::Offense]).void)
    ).returns(T.proc.params(path: ::String).returns(T::Array[::Packwerk::Offense]))
  end
  def process_file_proc(run_context, &block); end

  # source://packwerk//lib/packwerk/parse_run.rb#72
  sig do
    params(
      on_interrupt: T.nilable(T.proc.void),
      block: T.proc.params(path: ::String).returns(T::Array[::Packwerk::Offense])
    ).returns(T::Array[::Packwerk::Offense])
  end
  def serial_find_offenses(on_interrupt: T.unsafe(nil), &block); end
end

# source://packwerk//lib/packwerk/parse_run.rb#10
Packwerk::ParseRun::ProcessFileProc = T.type_alias { T.proc.params(path: ::String).returns(T::Array[::Packwerk::Offense]) }

# A collection of constant definitions parsed from an Abstract Syntax Tree (AST).
#
# source://packwerk//lib/packwerk/parsed_constant_definitions.rb#8
class Packwerk::ParsedConstantDefinitions
  # source://packwerk//lib/packwerk/parsed_constant_definitions.rb#30
  sig { params(root_node: T.nilable(::AST::Node)).void }
  def initialize(root_node:); end

  # source://packwerk//lib/packwerk/parsed_constant_definitions.rb#43
  sig do
    params(
      constant_name: ::String,
      location: T.nilable(::Packwerk::Node::Location),
      namespace_path: T::Array[::String]
    ).returns(T::Boolean)
  end
  def local_reference?(constant_name, location: T.unsafe(nil), namespace_path: T.unsafe(nil)); end

  private

  # source://packwerk//lib/packwerk/parsed_constant_definitions.rb#79
  sig do
    params(
      constant_name: ::String,
      current_namespace_path: T::Array[T.nilable(::String)],
      location: T.nilable(::Packwerk::Node::Location)
    ).void
  end
  def add_definition(constant_name, current_namespace_path, location); end

  # source://packwerk//lib/packwerk/parsed_constant_definitions.rb#55
  sig { params(node: ::AST::Node, current_namespace_path: T::Array[T.nilable(::String)]).void }
  def collect_local_definitions_from_root(node, current_namespace_path = T.unsafe(nil)); end

  class << self
    # What fully qualified constants can this constant refer to in this context?
    #
    # source://packwerk//lib/packwerk/parsed_constant_definitions.rb#16
    sig { params(constant_name: ::String, namespace_path: T::Array[T.nilable(::String)]).returns(T::Array[::String]) }
    def reference_qualifications(constant_name, namespace_path:); end
  end
end

# source://packwerk//lib/packwerk/parsers.rb#5
module Packwerk::Parsers; end

# source://packwerk//lib/packwerk/parsers/erb.rb#11
class Packwerk::Parsers::Erb
  include ::Packwerk::Parsers::ParserInterface

  # source://packwerk//lib/packwerk/parsers/erb.rb#17
  sig { params(parser_class: T.untyped, ruby_parser: ::Packwerk::Parsers::Ruby).void }
  def initialize(parser_class: T.unsafe(nil), ruby_parser: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/parsers/erb.rb#23
  sig { override.params(io: T.any(::IO, ::StringIO), file_path: ::String).returns(T.untyped) }
  def call(io:, file_path: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/parsers/erb.rb#30
  sig { params(buffer: ::Parser::Source::Buffer, file_path: ::String).returns(T.nilable(::AST::Node)) }
  def parse_buffer(buffer, file_path:); end

  private

  # @yield [node]
  #
  # source://packwerk//lib/packwerk/parsers/erb.rb#71
  sig do
    params(
      node: T.nilable(T.any(::AST::Node, ::String)),
      block: T.nilable(T.proc.params(arg0: ::AST::Node).void)
    ).returns(T.nilable(T.any(T::Array[::String], T::Enumerator[::AST::Node])))
  end
  def code_nodes(node, &block); end

  # source://packwerk//lib/packwerk/parsers/erb.rb#49
  sig { params(erb_ast: T.all(::AST::Node, ::Object), file_path: ::String).returns(T.nilable(::AST::Node)) }
  def to_ruby_ast(erb_ast, file_path); end
end

# source://packwerk//lib/packwerk/parsers/factory.rb#8
class Packwerk::Parsers::Factory
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://packwerk//lib/packwerk/parsers/factory.rb#24
  sig { void }
  def initialize; end

  # source://packwerk//lib/packwerk/parsers/factory.rb#41
  sig { returns(T::Class[T.anything]) }
  def erb_parser_class; end

  # source://packwerk//lib/packwerk/parsers/factory.rb#46
  sig { params(klass: T.nilable(T::Class[T.anything])).void }
  def erb_parser_class=(klass); end

  # source://packwerk//lib/packwerk/parsers/factory.rb#31
  sig { params(path: ::String).returns(T.nilable(::Packwerk::Parsers::ParserInterface)) }
  def for_path(path); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://packwerk//lib/packwerk/parsers/factory.rb#20
Packwerk::Parsers::Factory::ERB_REGEX = T.let(T.unsafe(nil), Regexp)

# source://packwerk//lib/packwerk/parsers/factory.rb#12
Packwerk::Parsers::Factory::RUBY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://packwerk//lib/packwerk/parsers.rb#13
class Packwerk::Parsers::ParseError < ::StandardError
  # source://packwerk//lib/packwerk/parsers.rb#20
  sig { params(result: ::Packwerk::Parsers::ParseResult).void }
  def initialize(result); end

  # source://packwerk//lib/packwerk/parsers.rb#17
  sig { returns(::Packwerk::Parsers::ParseResult) }
  def result; end
end

# source://packwerk//lib/packwerk/parsers.rb#11
class Packwerk::Parsers::ParseResult < ::Packwerk::Offense; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/parsers/parser_interface.rb#6
module Packwerk::Parsers::ParserInterface
  requires_ancestor { Kernel }

  interface!

  # @abstract
  #
  # source://packwerk//lib/packwerk/parsers/parser_interface.rb#15
  sig { abstract.params(io: T.any(::IO, ::StringIO), file_path: ::String).returns(T.untyped) }
  def call(io:, file_path:); end
end

# source://packwerk//lib/packwerk/parsers/ruby.rb#9
class Packwerk::Parsers::Ruby
  include ::Packwerk::Parsers::ParserInterface

  # source://packwerk//lib/packwerk/parsers/ruby.rb#41
  sig { params(parser_class: T.untyped).void }
  def initialize(parser_class: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/parsers/ruby.rb#47
  sig { override.params(io: T.any(::IO, ::StringIO), file_path: ::String).returns(T.nilable(::Parser::AST::Node)) }
  def call(io:, file_path: T.unsafe(nil)); end
end

# source://packwerk//lib/packwerk/parsers/ruby.rb#14
class Packwerk::Parsers::Ruby::RaiseExceptionsParser < ::Prism::Translation::Parser
  # source://packwerk//lib/packwerk/parsers/ruby.rb#18
  sig { params(builder: T.untyped).void }
  def initialize(builder); end

  private

  # source://packwerk//lib/packwerk/parsers/ruby.rb#26
  sig { params(error: ::Prism::ParseError).returns(T::Boolean) }
  def valid_error?(error); end
end

# source://packwerk//lib/packwerk/parsers/ruby.rb#31
class Packwerk::Parsers::Ruby::TolerateInvalidUtf8Builder < ::Parser::Builders::Default
  # source://packwerk//lib/packwerk/parsers/ruby.rb#35
  sig { params(token: T.untyped).returns(T.untyped) }
  def string_value(token); end
end

# source://packwerk//lib/packwerk/package_set.rb#8
Packwerk::PathSpec = T.type_alias { T.any(::String, T::Array[::String]) }

# Extracts the load paths from the analyzed application so that we can map constant names to paths.
#
# source://packwerk//lib/packwerk/rails_load_paths.rb#10
module Packwerk::RailsLoadPaths
  class << self
    # source://packwerk//lib/packwerk/rails_load_paths.rb#15
    sig { params(root: ::String, environment: ::String).returns(T::Hash[::String, ::Module]) }
    def for(root, environment:); end

    private

    # source://packwerk//lib/packwerk/rails_load_paths.rb#65
    sig { params(paths: T::Hash[T.untyped, ::Module]).void }
    def assert_load_paths_present(paths); end

    # source://packwerk//lib/packwerk/rails_load_paths.rb#26
    sig { returns(T::Hash[::String, ::Module]) }
    def extract_application_autoload_paths; end

    # source://packwerk//lib/packwerk/rails_load_paths.rb#36
    sig do
      params(
        all_paths: T::Hash[::String, ::Module],
        bundle_path: ::Pathname,
        rails_root: ::Pathname
      ).returns(T::Hash[::Pathname, ::Module])
    end
    def filter_relevant_paths(all_paths, bundle_path: T.unsafe(nil), rails_root: T.unsafe(nil)); end

    # source://packwerk//lib/packwerk/rails_load_paths.rb#47
    sig do
      params(
        load_paths: T::Hash[::Pathname, ::Module],
        rails_root: ::Pathname
      ).returns(T::Hash[::String, ::Module])
    end
    def relative_path_strings(load_paths, rails_root: T.unsafe(nil)); end

    # source://packwerk//lib/packwerk/rails_load_paths.rb#52
    sig { params(root: ::String, environment: ::String).void }
    def require_application(root, environment); end
  end
end

# A reference from a file in one package to a constant that may be defined in a different package.
#
# source://packwerk//lib/packwerk/reference.rb#6
class Packwerk::Reference < ::Struct
  # Returns the value of attribute constant
  #
  # @return [Object] the current value of constant
  def constant; end

  # Sets the attribute constant
  #
  # @param value [Object] the value to set the attribute constant to.
  # @return [Object] the newly set value
  def constant=(_); end

  # Returns the value of attribute package
  #
  # @return [Object] the current value of package
  def package; end

  # Sets the attribute package
  #
  # @param value [Object] the value to set the attribute package to.
  # @return [Object] the newly set value
  def package=(_); end

  # Returns the value of attribute relative_path
  #
  # @return [Object] the current value of relative_path
  def relative_path; end

  # Sets the attribute relative_path
  #
  # @param value [Object] the value to set the attribute relative_path to.
  # @return [Object] the newly set value
  def relative_path=(_); end

  # Returns the value of attribute source_location
  #
  # @return [Object] the current value of source_location
  def source_location; end

  # Sets the attribute source_location
  #
  # @param value [Object] the value to set the attribute source_location to.
  # @return [Object] the newly set value
  def source_location=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://packwerk//lib/packwerk.rb#88
module Packwerk::ReferenceChecking
  extend ::ActiveSupport::Autoload
end

# source://packwerk//lib/packwerk.rb#93
module Packwerk::ReferenceChecking::Checkers
  extend ::ActiveSupport::Autoload
end

# Checks whether a given reference conforms to the configured graph of dependencies.
#
# source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#8
class Packwerk::ReferenceChecking::Checkers::DependencyChecker
  include ::Packwerk::Checker

  # source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#24
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#36
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#51
  sig { override.params(offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(offense); end

  # source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#15
  sig { override.returns(::String) }
  def violation_type; end

  private

  # source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#59
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end
end

# source://packwerk//lib/packwerk/reference_checking/checkers/dependency_checker.rb#12
Packwerk::ReferenceChecking::Checkers::DependencyChecker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk//lib/packwerk/reference_checking/reference_checker.rb#6
class Packwerk::ReferenceChecking::ReferenceChecker
  # source://packwerk//lib/packwerk/reference_checking/reference_checker.rb#10
  sig { params(checkers: T::Array[::Packwerk::Checker]).void }
  def initialize(checkers); end

  # source://packwerk//lib/packwerk/reference_checking/reference_checker.rb#19
  sig { params(reference: ::Packwerk::Reference).returns(T::Array[::Packwerk::Offense]) }
  def call(reference); end
end

# Extracts a possible constant reference from a given AST node.
#
# source://packwerk//lib/packwerk/reference_extractor.rb#6
class Packwerk::ReferenceExtractor
  # source://packwerk//lib/packwerk/reference_extractor.rb#59
  sig do
    params(
      constant_name_inspectors: T::Array[::Packwerk::ConstantNameInspector],
      root_node: ::AST::Node,
      root_path: ::String
    ).void
  end
  def initialize(constant_name_inspectors:, root_node:, root_path:); end

  # source://packwerk//lib/packwerk/reference_extractor.rb#79
  sig do
    params(
      node: ::Parser::AST::Node,
      ancestors: T::Array[::Parser::AST::Node],
      relative_file: ::String
    ).returns(T.nilable(::Packwerk::UnresolvedReference))
  end
  def reference_from_node(node, ancestors:, relative_file:); end

  private

  # source://packwerk//lib/packwerk/reference_extractor.rb#113
  sig do
    params(
      inspector: ::Packwerk::ConstantNameInspector,
      node: ::Parser::AST::Node,
      ancestors: T::Array[::Parser::AST::Node],
      relative_file: ::String
    ).returns(T.nilable(::String))
  end
  def inspect_node(inspector, node:, ancestors:, relative_file:); end

  # source://packwerk//lib/packwerk/reference_extractor.rb#158
  sig do
    params(
      constant_name: ::String,
      name_location: T.nilable(::Packwerk::Node::Location),
      namespace_path: T::Array[::String]
    ).returns(T::Boolean)
  end
  def local_reference?(constant_name, name_location, namespace_path); end

  # source://packwerk//lib/packwerk/reference_extractor.rb#136
  sig do
    params(
      constant_name: ::String,
      node: ::Parser::AST::Node,
      ancestors: T::Array[::Parser::AST::Node],
      relative_file: ::String
    ).returns(T.nilable(::Packwerk::UnresolvedReference))
  end
  def reference_from_constant(constant_name, node:, ancestors:, relative_file:); end

  class << self
    # source://packwerk//lib/packwerk/reference_extractor.rb#18
    sig do
      params(
        unresolved_references: T::Array[::Packwerk::UnresolvedReference],
        context_provider: ::Packwerk::ConstantDiscovery
      ).returns(T::Array[::Packwerk::Reference])
    end
    def get_fully_qualified_references_from(unresolved_references, context_provider); end
  end
end

# An offense related to a {Packwerk::Reference}.
#
# source://packwerk//lib/packwerk/reference_offense.rb#6
class Packwerk::ReferenceOffense < ::Packwerk::Offense
  # source://packwerk//lib/packwerk/reference_offense.rb#25
  sig do
    params(
      reference: ::Packwerk::Reference,
      violation_type: ::String,
      message: ::String,
      location: T.nilable(::Packwerk::Node::Location)
    ).void
  end
  def initialize(reference:, violation_type:, message:, location: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/reference_offense.rb#11
  sig { returns(::Packwerk::Reference) }
  def reference; end

  # source://packwerk//lib/packwerk/reference_offense.rb#14
  sig { returns(::String) }
  def violation_type; end
end

# Holds the context of a Packwerk run across multiple files.
#
# source://packwerk//lib/packwerk/run_context.rb#8
class Packwerk::RunContext
  # source://packwerk//lib/packwerk/run_context.rb#46
  sig do
    params(
      root_path: ::String,
      load_paths: T::Hash[::String, ::Module],
      inflector: T.class_of(ActiveSupport::Inflector),
      cache_directory: ::Pathname,
      config_path: T.nilable(::String),
      package_paths: T.nilable(T.any(::String, T::Array[::String])),
      custom_associations: T.any(T::Array[::Symbol], T::Set[::Symbol]),
      associations_exclude: T::Array[::String],
      checkers: T::Array[::Packwerk::Checker],
      cache_enabled: T::Boolean
    ).void
  end
  def initialize(root_path:, load_paths:, inflector:, cache_directory:, config_path: T.unsafe(nil), package_paths: T.unsafe(nil), custom_associations: T.unsafe(nil), associations_exclude: T.unsafe(nil), checkers: T.unsafe(nil), cache_enabled: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/run_context.rb#92
  sig { returns(Packwerk::PackageSet) }
  def package_set; end

  # source://packwerk//lib/packwerk/run_context.rb#79
  sig { params(relative_file: ::String).returns(T::Array[::Packwerk::Offense]) }
  def process_file(relative_file:); end

  private

  # source://packwerk//lib/packwerk/run_context.rb#130
  sig { returns(T::Array[::Packwerk::ConstantNameInspector]) }
  def constant_name_inspectors; end

  # source://packwerk//lib/packwerk/run_context.rb#113
  sig { returns(::Packwerk::ConstantDiscovery) }
  def context_provider; end

  # source://packwerk//lib/packwerk/run_context.rb#99
  sig { returns(::Packwerk::FileProcessor) }
  def file_processor; end

  # source://packwerk//lib/packwerk/run_context.rb#104
  sig { returns(::Packwerk::NodeProcessorFactory) }
  def node_processor_factory; end

  # source://packwerk//lib/packwerk/run_context.rb#142
  sig { params(relative_globs: T::Array[::String]).returns(T::Set[::String]) }
  def relative_files_for_globs(relative_globs); end

  # source://packwerk//lib/packwerk/run_context.rb#121
  sig { returns(::ConstantResolver) }
  def resolver; end

  class << self
    # source://packwerk//lib/packwerk/run_context.rb#17
    sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::RunContext) }
    def from_configuration(configuration); end
  end
end

# An unresolved reference from a file in one package to a constant that may be defined in a different package.
# Unresolved means that we know how it's referred to in the file,
# and we have enough context on that reference to figure out the fully qualified reference such that we
# can produce a Reference in a separate pass. However, we have not yet resolved it to its fully qualified version.
#
# source://packwerk//lib/packwerk/unresolved_reference.rb#9
class Packwerk::UnresolvedReference < ::Struct
  # Returns the value of attribute constant_name
  #
  # @return [Object] the current value of constant_name
  def constant_name; end

  # Sets the attribute constant_name
  #
  # @param value [Object] the value to set the attribute constant_name to.
  # @return [Object] the newly set value
  def constant_name=(_); end

  # Returns the value of attribute namespace_path
  #
  # @return [Object] the current value of namespace_path
  def namespace_path; end

  # Sets the attribute namespace_path
  #
  # @param value [Object] the value to set the attribute namespace_path to.
  # @return [Object] the newly set value
  def namespace_path=(_); end

  # Returns the value of attribute relative_path
  #
  # @return [Object] the current value of relative_path
  def relative_path; end

  # Sets the attribute relative_path
  #
  # @param value [Object] the value to set the attribute relative_path to.
  # @return [Object] the newly set value
  def relative_path=(_); end

  # Returns the value of attribute source_location
  #
  # @return [Object] the current value of source_location
  def source_location; end

  # Sets the attribute source_location
  #
  # @param value [Object] the value to set the attribute source_location to.
  # @return [Object] the newly set value
  def source_location=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://packwerk//lib/packwerk/version.rb#5
Packwerk::VERSION = T.let(T.unsafe(nil), String)

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://packwerk//lib/packwerk/validator.rb#9
module Packwerk::Validator
  extend ::ActiveSupport::Autoload

  abstract!

  # @abstract
  #
  # source://packwerk//lib/packwerk/validator.rb#50
  sig do
    abstract
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk//lib/packwerk/validator.rb#81
  sig do
    params(
      results: T::Array[::Packwerk::Validator::Result],
      separator: ::String,
      before_errors: ::String,
      after_errors: ::String
    ).returns(::Packwerk::Validator::Result)
  end
  def merge_results(results, separator: T.unsafe(nil), before_errors: T.unsafe(nil), after_errors: T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/validator.rb#69
  sig { params(configuration: ::Packwerk::Configuration).returns(T.any(::String, T::Array[::String])) }
  def package_glob(configuration); end

  # source://packwerk//lib/packwerk/validator.rb#62
  sig do
    params(
      configuration: ::Packwerk::Configuration,
      glob_pattern: T.nilable(T.any(::String, T::Array[::String]))
    ).returns(T::Array[::String])
  end
  def package_manifests(configuration, glob_pattern = T.unsafe(nil)); end

  # source://packwerk//lib/packwerk/validator.rb#54
  sig { params(configuration: ::Packwerk::Configuration, setting: T.untyped).returns(T.untyped) }
  def package_manifests_settings_for(configuration, setting); end

  # @abstract
  #
  # source://packwerk//lib/packwerk/validator.rb#46
  sig { abstract.returns(T::Array[::String]) }
  def permitted_keys; end

  # source://packwerk//lib/packwerk/validator.rb#100
  sig { params(configuration: ::Packwerk::Configuration, path: ::String).returns(::Pathname) }
  def relative_path(configuration, path); end

  class << self
    # source://packwerk//lib/packwerk/validator.rb#27
    sig { returns(T::Array[::Packwerk::Validator]) }
    def all; end

    # source://packwerk//lib/packwerk/validator.rb#22
    sig { params(base: T::Class[T.anything]).void }
    def included(base); end

    private

    # source://packwerk//lib/packwerk/validator.rb#35
    sig { void }
    def load_defaults; end

    # source://packwerk//lib/packwerk/validator.rb#40
    sig { returns(T::Array[T::Class[T.anything]]) }
    def validators; end
  end
end

# source://packwerk//lib/packwerk/validator/result.rb#6
class Packwerk::Validator::Result < ::T::Struct
  const :ok, T::Boolean
  const :error_value, T.nilable(::String)

  # source://packwerk//lib/packwerk/validator/result.rb#13
  sig { returns(T::Boolean) }
  def ok?; end

  class << self
    # source://sorbet-runtime/0.5.11874/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk//lib/packwerk.rb#51
module Packwerk::Validators
  extend ::ActiveSupport::Autoload
end

# source://packwerk//lib/packwerk/validators/dependency_validator.rb#6
class Packwerk::Validators::DependencyValidator
  include ::Packwerk::Validator

  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#24
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end

  private

  # Convert the cycles:
  #
  #   [[a, b, c], [b, c]]
  #
  # to the string:
  #
  #   ["a -> b -> c -> a", "b -> c -> b"]
  #
  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#145
  sig { params(cycles: T.untyped).returns(T::Array[::String]) }
  def build_cycle_strings(cycles); end

  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#67
  sig { params(package_set: Packwerk::PackageSet).returns(::Packwerk::Validator::Result) }
  def check_acyclic_graph(package_set); end

  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#34
  sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::Validator::Result) }
  def check_package_manifest_syntax(configuration); end

  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#93
  sig { params(configuration: ::Packwerk::Configuration).returns(::Packwerk::Validator::Result) }
  def check_valid_package_dependencies(configuration); end

  # source://packwerk//lib/packwerk/validators/dependency_validator.rb#129
  sig { params(configuration: ::Packwerk::Configuration, path: T.untyped).returns(T::Boolean) }
  def invalid_package_path?(configuration, path); end
end
