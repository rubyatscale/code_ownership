# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-gusto` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-gusto`.


# This cop enforces that polymorphic relations have a corresponding validation
# for their type field with an inclusion validation. This is required in order for Tapioca
# to generate correct Sorbet types
#
# source://rubocop-gusto//lib/rubocop/gusto/version.rb#3
module RuboCop; end

# source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#4
module RuboCop::Cop; end

# source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#5
module RuboCop::Cop::Gusto; end

# Do not use Bootsnap to load files. Use `require` instead.
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#7
class RuboCop::Cop::Gusto::BootsnapLoadFile < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#15
  def file_read(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#18
  def load_inside_file_open(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#31
  def on_block(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#31
  def on_numblock(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#38
  def on_send(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#12
  def yaml_or_json_load(param0 = T.unsafe(nil)); end

  private

  # Look for File.read as the first argument
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#47
  def on_load(node, constant_node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#8
RuboCop::Cop::Gusto::BootsnapLoadFile::PROHIBITED_CONSTANTS = T.let(T.unsafe(nil), Set)

# source://rubocop-gusto//lib/rubocop/cop/gusto/bootsnap_load_file.rb#9
RuboCop::Cop::Gusto::BootsnapLoadFile::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-gusto//lib/rubocop/cop/gusto/datadog_constant.rb#6
class RuboCop::Cop::Gusto::DatadogConstant < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/datadog_constant.rb#10
  def on_const(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/datadog_constant.rb#7
RuboCop::Cop::Gusto::DatadogConstant::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/datadog_constant.rb#8
RuboCop::Cop::Gusto::DatadogConstant::NAMESPACE = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/execute_migration.rb#6
class RuboCop::Cop::Gusto::ExecuteMigration < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/execute_migration.rb#10
  def on_send(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/execute_migration.rb#7
RuboCop::Cop::Gusto::ExecuteMigration::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/execute_migration.rb#8
RuboCop::Cop::Gusto::ExecuteMigration::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-gusto//lib/rubocop/cop/gusto/factory_classes_or_modules.rb#6
class RuboCop::Cop::Gusto::FactoryClassesOrModules < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/factory_classes_or_modules.rb#9
  def on_class(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/factory_classes_or_modules.rb#13
  def on_module(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/factory_classes_or_modules.rb#7
RuboCop::Cop::Gusto::FactoryClassesOrModules::MSG = T.let(T.unsafe(nil), String)

# Checks for the use of `min` or `max` with a proc. Corrects to `min_by` or `max_by`.
#
# @example
#   # bad
#   arr = [[3, 3, 3], [2, 2], [1]]
#   arr.min(&:count)
#   => [3, 3, 3] - oh no how did this happen?
#   arr = [[2,2],[1,1],[3,3,3]]
#   arr.min &:first # => TypeError: no implicit conversion of Array into Integer
#   arr = [[1, 1], [3, 3], [2, 2]]
#   arr.max { |pair| pair.first } # => [2, 2] (semantically incorrect)
#
#   # good
#   arr = [[2,2],[1],[3,3,3]]
#   arr.min_by &:first # => [1]
#   arr = [[1, 1], [3, 3], [2, 2]]
#   arr.max_by { |pair| pair.first } # => [3, 3]
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/min_by_max_by.rb#26
class RuboCop::Cop::Gusto::MinByMaxBy < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-gusto//lib/rubocop/cop/gusto/min_by_max_by.rb#32
  def on_csend(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/min_by_max_by.rb#32
  def on_send(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/min_by_max_by.rb#29
RuboCop::Cop::Gusto::MinByMaxBy::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/min_by_max_by.rb#30
RuboCop::Cop::Gusto::MinByMaxBy::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks and discourages the use of metaprogramming techniques that make code harder to
# understand, debug, and maintain.
#
# @example
#
#   # bad - using define_method
#   define_method(:my_method) do |arg|
#   puts arg
#   end
#
#   # good - using regular method definition
#   def my_method(arg)
#   puts arg
#   end
#
#   # bad - using instance_eval
#   object.instance_eval do
#   def foo
#   bar
#   end
#   end
#
#   # good - defining methods on the class
#   class MyClass
#   def foo
#   bar
#   end
#   end
#
#   # bad - using method_missing
#   def method_missing(method, *args)
#   if method.to_s.start_with?('find_by_')
#   # ...
#   end
#   end
#
#   # bad - using define_singleton_method
#   object.define_singleton_method(:foo) { bar }
#
#   # good - define class methods directly
#   def self.foo
#   bar
#   end
#
#   # bad - using class_eval
#   MyClass.class_eval do
#   def foo
#   bar
#   end
#   end
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#57
class RuboCop::Cop::Gusto::NoMetaprogramming < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#61
  def included_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#66
  def inherited_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#105
  def on_def(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#95
  def on_defs(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#111
  def on_send(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#86
  def using_class_eval?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#76
  def using_define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#91
  def using_define_singleton_method_on_klass_instance?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#81
  def using_instance_eval?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#71
  def using_method_missing?(param0 = T.unsafe(nil)); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/no_metaprogramming.rb#58
RuboCop::Cop::Gusto::NoMetaprogramming::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the presence of error message checking within rescue blocks.
#
# This is brittle and can break easily.
#
# NOTE: We submitted this upstream here: https://github.com/rubocop/rubocop/pull/13352
#
#  # bad
#  begin
#    something
#  rescue => e
#    unless e.message.match?(/Duplicate entry/)
#      handle_error
#    end
#  end
#
#   # good
#   begin
#     something
#   rescue ActiveRecord::RecordNotUnique => e
#     handle_error
#   end
#
# @example
#
#   # bad
#   begin
#   something
#   rescue => e
#   if e.message.match?(/Duplicate entry/)
#   handle_error
#   end
#   end
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/no_rescue_error_message_checking.rb#39
class RuboCop::Cop::Gusto::NoRescueErrorMessageChecking < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_rescue_error_message_checking.rb#43
  def on_rescue(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_rescue_error_message_checking.rb#51
  def message_check?(condition_node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/no_rescue_error_message_checking.rb#41
RuboCop::Cop::Gusto::NoRescueErrorMessageChecking::METHODS_TO_CHECK = T.let(T.unsafe(nil), Set)

# source://rubocop-gusto//lib/rubocop/cop/gusto/no_rescue_error_message_checking.rb#40
RuboCop::Cop::Gusto::NoRescueErrorMessageChecking::MSG = T.let(T.unsafe(nil), String)

# Do not call a private method via __send__
#
# @example
#   # bad
#   foo.__send__(:bar)
#   __send__(:run_baz)
#
#   # good
#   There's no better alternative, don't call private methods.
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/no_send.rb#16
class RuboCop::Cop::Gusto::NoSend < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_send.rb#21
  def invoke_private_method_send?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_send.rb#25
  def on_csend(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/no_send.rb#25
  def on_send(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/no_send.rb#17
RuboCop::Cop::Gusto::NoSend::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/no_send.rb#18
RuboCop::Cop::Gusto::NoSend::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Identifies uses of `Object#in?`, which iterates over each
# item in a `Range` to see if a specified item is there. In contrast,
# `Range#cover?` simply compares the target item with the beginning and
# end points of the `Range`. In a great majority of cases, this is what
# is wanted.
#
# This cop is unsafe. Here is an example of a case where `Range#cover?`
# may not provide the desired result:
#
#  ('a'..'z').cover?('yellow') # => true
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/object_in.rb#18
class RuboCop::Cop::Gusto::ObjectIn < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/object_in.rb#23
  def object_in(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/object_in.rb#27
  def on_csend(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/object_in.rb#27
  def on_send(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/object_in.rb#19
RuboCop::Cop::Gusto::ObjectIn::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/object_in.rb#20
RuboCop::Cop::Gusto::ObjectIn::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-gusto//lib/rubocop/cop/gusto/paperclip_or_attachable.rb#7
class RuboCop::Cop::Gusto::PaperclipOrAttachable < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/paperclip_or_attachable.rb#11
  def on_send(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/paperclip_or_attachable.rb#8
RuboCop::Cop::Gusto::PaperclipOrAttachable::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/paperclip_or_attachable.rb#9
RuboCop::Cop::Gusto::PaperclipOrAttachable::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for a defined `.perform` class method in Sidekiq workers. These
# are most likely intended to have been instance methods.
#
# @example
#   # bad
#   class MyWorker
#   include Sidekiq::Worker
#
#   def self.perform
#   # ...
#   end
#   end
#
#   # good
#   class MyWorker
#   include Sidekiq::Worker
#
#   def perform
#   # ...
#   end
#   end
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#28
class RuboCop::Cop::Gusto::PerformClassMethod < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#33
  def on_def(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#33
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#63
  def is_include?(node); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#52
  def is_sidekiq_worker?(search_node, method_type); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#44
  def perform_class_method_type(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#67
  def worker_modules; end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#29
RuboCop::Cop::Gusto::PerformClassMethod::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#30
RuboCop::Cop::Gusto::PerformClassMethod::WORKER_FALLBACK = T.let(T.unsafe(nil), Array)

# source://rubocop-gusto//lib/rubocop/cop/gusto/perform_class_method.rb#31
RuboCop::Cop::Gusto::PerformClassMethod::WORKER_MODULES = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#9
class RuboCop::Cop::Gusto::PolymorphicTypeValidation < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#54
  def allow_blank?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#44
  def inclusion_in?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#58
  def on_send(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#49
  def polymorphic_methods_for?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#34
  def polymorphic_relation?(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#39
  def type_validation?(param0 = T.unsafe(nil)); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#31
RuboCop::Cop::Gusto::PolymorphicTypeValidation::ALLOW_BLANK_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#12
RuboCop::Cop::Gusto::PolymorphicTypeValidation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/polymorphic_type_validation.rb#10
RuboCop::Cop::Gusto::PolymorphicTypeValidation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Don't use the `$?` or `$CHILD_STATUS` global variables. Instead, use `Process.last_status`
#
# @example
#   # bad
#   $?.exitstatus
#   $CHILD_STATUS.success?
#
#   # good
#   Process.last_status.exit_status
#   Process.last_status.success?
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/prefer_process_last_status.rb#17
class RuboCop::Cop::Gusto::PreferProcessLastStatus < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-gusto//lib/rubocop/cop/gusto/prefer_process_last_status.rb#29
  def autocorrect(corrector, node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/prefer_process_last_status.rb#23
  def on_gvar(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/prefer_process_last_status.rb#20
RuboCop::Cop::Gusto::PreferProcessLastStatus::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/prefer_process_last_status.rb#21
RuboCop::Cop::Gusto::PreferProcessLastStatus::OFFENDERS = T.let(T.unsafe(nil), Set)

# Disallows the use of `extends` in Rabl templates due to poor caching performance.
# Inline the templating to generate your JSON instead.
#
# @example
#   # bad
#   extends 'path/to/template'
#
#   # bad - but not covered by this rule
#   partial 'path/to/template'
#
#   # good - inline your templating
#   node 'some_node'
#   attributes :foo, :bar
#   child(:baz) { attributes :qux }
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#21
class RuboCop::Cop::Gusto::RablExtends < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#31
  def on_send(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#27
  def rabl_extends?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#37
  def relevant_file?(file); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#22
RuboCop::Cop::Gusto::RablExtends::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#23
RuboCop::Cop::Gusto::RablExtends::RABL_EXTENSION = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/rabl_extends.rb#24
RuboCop::Cop::Gusto::RablExtends::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# NOTE: Being pushed upstream here: https://github.com/rubocop/rubocop-rails/pull/1375
# Checks for usage of `Rails.env` which can be replaced with Feature Flags
#
# Although `local?` is a form of an environment-specific check, it is allowed because
# it cannot be used to control overall environment rollout, but it can be helpful to
# distinguish or protect code that is explicitly written to only ever execute in a
# dev or test environment. `local?` is also a form of a feature flag.
#
# @example
#
#   # bad
#   Rails.env.production? || Rails.env.demo?
#
#   # good
#   if FeatureFlag.enabled?(:new_feature)
#   # new feature code
#   end
#
#   # good
#   raise unless Rails.env.local?
#
#   # good
#   abort ("The Rails environment is running in production mode!") unless Rails.env.local?
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/rails_env.rb#30
class RuboCop::Cop::Gusto::RailsEnv < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/rails_env.rb#58
  def on_send(node); end
end

# This allow list is derived from:
# (Rails.env.methods - Object.instance_methods).select { |m| m.to_s.end_with?('?') }
# and then removing the environment specific methods like development?, test?, production?
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/rails_env.rb#34
RuboCop::Cop::Gusto::RailsEnv::ALLOWED_LIST = T.let(T.unsafe(nil), Set)

# source://rubocop-gusto//lib/rubocop/cop/gusto/rails_env.rb#54
RuboCop::Cop::Gusto::RailsEnv::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/rails_env.rb#55
RuboCop::Cop::Gusto::RailsEnv::PROHIBITED_CLASS = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/rails_env.rb#56
RuboCop::Cop::Gusto::RailsEnv::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Detects constants in a rake file because they are defined at the top level.
# It is confusing because the scope looks like it would be in the task or namespace,
# but actually it is defined at the top level.
#
# @example
#   # bad
#   task :foo do
#   class C
#   end
#   end
#
#   # bad
#   namespace :foo do
#   module M
#   end
#   end
#
#   # good - It is also defined at the top level,
#   #        but it looks like intended behavior.
#   class C
#   end
#   task :foo do
#   end
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#30
class RuboCop::Cop::Gusto::RakeConstants < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#42
  def on_casgn(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#48
  def on_class(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#54
  def on_module(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#34
  def task_or_namespace?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#62
  def in_task_or_namespace?(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/rake_constants.rb#31
RuboCop::Cop::Gusto::RakeConstants::MSG = T.let(T.unsafe(nil), String)

# Ensures that regular expressions use `\A` and `\z` anchors instead
# of `^` and `$` when matching the start or end of a string. This is
# critical for security validations as `^` and `$` will match the start/end
# of any line in a string, not just the start/end of the entire string.
#
# @example
#   # bad - validating only a single line of input which could be split across multiple lines
#   /^foo/
#   /foo$/
#   /^foo$/
#
#   # good
#   /\Afoo/
#   /foo\z/
#   /\Afoo\z/
#
#   # good - multiline mode is allowed
#   /^foo/m
#   /foo$/m
#
#   # okay - anchors in the middle of the pattern are not flagged
#   /foo^bar/
#   /foo$bar/
# @see https://ruby-doc.org/core/Regexp.html
# @see https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/regexp_bypass.rb#38
class RuboCop::Cop::Gusto::RegexpBypass < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-gusto//lib/rubocop/cop/gusto/regexp_bypass.rb#45
  def on_regexp(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/regexp_bypass.rb#41
RuboCop::Cop::Gusto::RegexpBypass::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/regexp_bypass.rb#42
RuboCop::Cop::Gusto::RegexpBypass::PROHIBITED_ANCHOR = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/regexp_bypass.rb#43
RuboCop::Cop::Gusto::RegexpBypass::PROHIBITED_END_ANCHOR = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/sidekiq_params.rb#6
class RuboCop::Cop::Gusto::SidekiqParams < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/sidekiq_params.rb#10
  def on_def(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/sidekiq_params.rb#7
RuboCop::Cop::Gusto::SidekiqParams::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/sidekiq_params.rb#8
RuboCop::Cop::Gusto::SidekiqParams::PROHIBITED_ARG_TYPES = T.let(T.unsafe(nil), Set)

# Checks that no top-level constants (excluding classes and modules)
# are defined. This rule exists to prevent accidental pollution of the
# global namespace as well as cases where application code has
# accidentally depended on test code.
#
# By default, this check is limited to files in `app/`, `lib/`, and
# `spec/` directories, except in the root of `lib/` and in support files
# in `spec/support/`.
#
# @example when in a checked directory
#   # bad
#   FOO = 'bar' # lib/foo/bar.rb
#
#   # bad
#   FOO = 'bar' # app/models/foo.rb
#
#   # bad
#   FOO = 'bar' # spec/foo.rb
#
#   # good
#   FOO = 'bar' # spec/spec_helper.rb
#
#   # good
#   class MyClass # lib/foo/bar.rb
#   FOO = 'bar'
#   end
# @example when in a `spec/support/` file
#   # good
#   FOO = 'bar' # spec/support/foo/bar.rb
# @example when in a `config/` file
#   # good
#   FOO = 'bar' # config/initializers/foo.rb
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/toplevel_constants.rb#41
class RuboCop::Cop::Gusto::ToplevelConstants < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/gusto/toplevel_constants.rb#44
  def on_casgn(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/toplevel_constants.rb#42
RuboCop::Cop::Gusto::ToplevelConstants::MSG = T.let(T.unsafe(nil), String)

# Requires the use of the `paint` gem for terminal color methods on strings
#
# @example
#
#   # bad
#   "string".cyan
#   "string".red
#   "string".green
#   str = "hello"
#   str.cyan
#   "string".colorize(:blue)
#   "string".colorize(:color => :blue)
#   "string".colorize(:color => :blue, :background => :red)
#   "string".blue.on_red
#   "string".colorize(:blue).on_red
#   "string".blue.underline
#
#   # good
#   "string"
#
#   # if color is needed, use `paint` gem
#   Paint["string", :cyan]
#   Paint["string", :red]
#   Paint["string", :green]
#   Paint[str, :cyan]
#   Paint["string", :blue]
#   Paint["string", :blue, :red]
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#34
class RuboCop::Cop::Gusto::UsePaintNotColorize < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#108
  def on_csend(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#99
  def on_send(node); end

  private

  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#216
  def build_paint_call(string_node, foreground, background, styles); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#124
  def colorized_string?(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#130
  def correction(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#196
  def extract_string_and_operations(node); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#116
  def string_or_colorized_receiver?(node); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#120
  def string_receiver?(node); end
end

# Common terminal color methods that should be prevented
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#38
RuboCop::Cop::Gusto::UsePaintNotColorize::COLOR_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#95
RuboCop::Cop::Gusto::UsePaintNotColorize::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#96
RuboCop::Cop::Gusto::UsePaintNotColorize::PROHIBITED_CLASS = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#97
RuboCop::Cop::Gusto::UsePaintNotColorize::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Style modifiers that are applied as additional options in Paint
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/use_paint_not_colorize.rb#84
RuboCop::Cop::Gusto::UsePaintNotColorize::STYLE_MODIFIERS = T.let(T.unsafe(nil), Set)

# Requires VCR to be set to not record in tests.
#
# @example
#   # bad
#   vcr: {record: :all}
#
#   # good
#   vcr: {record: :none}
# @see https://github.com/vcr/vcr
#
# source://rubocop-gusto//lib/rubocop/cop/gusto/vcr_recordings.rb#17
class RuboCop::Cop::Gusto::VcrRecordings < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-gusto//lib/rubocop/cop/gusto/vcr_recordings.rb#27
  def on_pair(node); end

  # source://rubocop-gusto//lib/rubocop/cop/gusto/vcr_recordings.rb#23
  def vcr_recording?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/vcr_recordings.rb#43
  def recording_enabled?(option, value); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/cop/gusto/vcr_recordings.rb#39
  def vcr_setting?(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/gusto/vcr_recordings.rb#20
RuboCop::Cop::Gusto::VcrRecordings::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-gusto//lib/rubocop/cop/internal_affairs/assignment_first.rb#5
module RuboCop::Cop::InternalAffairs; end

# Check for assignment as the first action in a cop hook.
#
# @example
#   # bad
#   def on_send(node)
#   foo = 1
#   do_something
#   end
#
#   # good
#   def on_send(node)
#   do_something
#   foo = 1
#   end
#
# source://rubocop-gusto//lib/rubocop/cop/internal_affairs/assignment_first.rb#21
class RuboCop::Cop::InternalAffairs::AssignmentFirst < ::RuboCop::Cop::Base
  # source://rubocop-gusto//lib/rubocop/cop/internal_affairs/assignment_first.rb#43
  def on_def(node); end
end

# source://rubocop-gusto//lib/rubocop/cop/internal_affairs/assignment_first.rb#22
RuboCop::Cop::InternalAffairs::AssignmentFirst::HOOKS = T.let(T.unsafe(nil), Set)

# source://rubocop-gusto//lib/rubocop/cop/internal_affairs/assignment_first.rb#41
RuboCop::Cop::InternalAffairs::AssignmentFirst::MSG = T.let(T.unsafe(nil), String)

# Check for missing `RESTRICT_ON_SEND`.
#
# NOTE: This works for us because we do not write cops that investigate every send node.
# Upstream Rubocop chose not to implement this as there are many cops in Core that investigate every node.
#
# @example
#   # bad
#   class FooCop
#   def on_send(node)
#   # ...
#   end
#   end
#
#   # good
#   class FooCop
#   RESTRICT_ON_SEND = %i[bad_method].freeze
#   def on_send(node)
#   # ...
#   end
#   end
#
# source://rubocop-gusto//lib/rubocop/cop/internal_affairs/require_restrict_on_send.rb#26
class RuboCop::Cop::InternalAffairs::RequireRestrictOnSend < ::RuboCop::Cop::Base
  # from: https://github.com/rubocop/rubocop/blob/e78790e3c9e82f8e605009673a8d2eac40b18c4c/lib/rubocop/cop/internal_affairs/undefined_config.rb#L25
  #
  # source://rubocop-gusto//lib/rubocop/cop/internal_affairs/require_restrict_on_send.rb#45
  def cop_class_def(param0 = T.unsafe(nil)); end

  # source://rubocop-gusto//lib/rubocop/cop/internal_affairs/require_restrict_on_send.rb#30
  def defined_send_callback?(param0); end

  # source://rubocop-gusto//lib/rubocop/cop/internal_affairs/require_restrict_on_send.rb#51
  def on_class(node); end

  # source://rubocop-gusto//lib/rubocop/cop/internal_affairs/require_restrict_on_send.rb#39
  def restrict_on_send?(param0); end
end

# source://rubocop-gusto//lib/rubocop/cop/internal_affairs/require_restrict_on_send.rb#27
RuboCop::Cop::InternalAffairs::RequireRestrictOnSend::MSG = T.let(T.unsafe(nil), String)

# RuboCop Gusto project namespace.
#
# source://rubocop-gusto//lib/rubocop/gusto/version.rb#4
module RuboCop::Gusto; end

# A plugin that integrates Gusto's standard RuboCop cops and rules.
#
# source://rubocop-gusto//lib/rubocop/gusto/plugin.rb#8
class RuboCop::Gusto::Plugin < ::LintRoller::Plugin
  # source://rubocop-gusto//lib/rubocop/gusto/plugin.rb#9
  def about; end

  # source://rubocop-gusto//lib/rubocop/gusto/plugin.rb#22
  def rules(_context); end

  # @return [Boolean]
  #
  # source://rubocop-gusto//lib/rubocop/gusto/plugin.rb#18
  def supported?(context); end
end

# source://rubocop-gusto//lib/rubocop/gusto/version.rb#5
RuboCop::Gusto::VERSION = T.let(T.unsafe(nil), String)
